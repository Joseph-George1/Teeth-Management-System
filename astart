#!/usr/bin/env bash


# Colors
RED="\033[1;31m"
GREEN="\033[1;32m"
YELLOW="\033[1;33m"
BLUE="\033[1;34m"
NC="\033[0m"

# Verbose flag
VERBOSE=0

# Load configuration from .env file if it exists
ENV_FILE="$HOME/Teeth-Management-System/.env"
if [ -f "$ENV_FILE" ]; then
    set -a
    source "$ENV_FILE"
    set +a
fi

# Database configuration (use env vars or defaults)
# Detected from: Backend/src/main/resources/application.properties
DB_URL="${DB_URL:-jdbc:oracle:thin:@localhost:1521/orclpdb}"
DB_USERNAME="${DB_USERNAME:-hr}"
DB_PASSWORD="${DB_PASSWORD:-hr}"

# Port configuration (detected from project files)
# Web UI: Vite default port (vite.config.js)
# Backend: Spring Boot default port (no custom server.port in application.properties)
# AI API: Detected from Ai-chatbot/api.py line 581
# Login API: Detected from Backend/loginapi.py line 291
WEB_UI_PORT="${WEB_UI_PORT:-5173}"
BACKEND_PORT="${BACKEND_PORT:-8080}"
API_PORT="${API_PORT:-5010}"
LOGIN_API_PORT="${LOGIN_API_PORT:-5000}"
OTP_PORT="${OTP_PORT:-8000}"
#-------------------------------------------------------------
# Logging subsystem
# Purpose: centralized, human-readable logging for the launcher.
# - Creates a global activity log (`astart_activity.log`) with one-line
#   records for each start/stop and launcher events (timestamp, user, ip,
#   flag, process, exit code when applicable).
# - Maintains per-process log files under `process_logs/` which contain
#   a START block, the full stdout/stderr output (redirected), and a
#   STOP block with the exit code and timestamp.
# - Stores PID files for backgrounded processes under `pids/` so the
#   launcher (or other tooling) can locate and stop/reread PIDs.
#
# Notes:
# - Designed for interactive developer use on a Unix-like host (bash).
# - Uses AWS metadata service to attempt to record instance public IP
#   when available; falls back to public IP services or hostname.
#-------------------------------------------------------------

# Define paths
core_path="$HOME/Teeth-Management-System/Ai-chatbot"
webui_path="$HOME/Teeth-Management-System/Thoutha-Website"
backend_path="$HOME/Teeth-Management-System/BackEnd"
LOG_DIR="$HOME/Teeth-Management-System/logs"
PROCESS_LOG_DIR="$LOG_DIR/process_logs"
PID_DIR="$LOG_DIR/pids"
ACTIVITY_LOG="$LOG_DIR/astart_activity.log"
server_dir="/var/www/html"
otp_dir="$HOME/Teeth-Management-System/OTP"


#-------------------------------------------------------------
# verbose_log
# Print verbose debug messages when VERBOSE=1
# Parameters:
# - $1: message (string)
#-------------------------------------------------------------
verbose_log() {
    if [ "$VERBOSE" -eq 1 ] 2>/dev/null; then
        echo -e "${YELLOW}[VERBOSE]${NC} $1" >&2
    fi
}

#-------------------------------------------------------------
# validate_paths
# Validates that all required directories exist
# Returns: 0 if all paths valid, 1 otherwise
#-------------------------------------------------------------
validate_paths() {
    local valid=0
    
    if [ ! -d "$core_path" ]; then
        echo -e "${RED}ERROR: AI Chatbot path does not exist: $core_path${NC}"
        valid=1
    fi
    
    if [ ! -d "$webui_path" ]; then
        echo -e "${RED}ERROR: Web UI path does not exist: $webui_path${NC}"
        valid=1
    fi
    
    if [ ! -d "$backend_path" ]; then
        echo -e "${RED}ERROR: Backend path does not exist: $backend_path${NC}"
        valid=1
    fi
    
    if [ ! -d "$otp_dir" ]; then
        echo -e "${RED}ERROR: OTP path does not exist: $otp_dir${NC}"
        valid=1
    fi

    
    return $valid
}

#-------------------------------------------------------------
# check_port
# Check if a port is already in use
# Parameters:
# - $1: port number
# Returns: 0 if port is free, 1 if in use
#-------------------------------------------------------------
check_port() {
    local port=$1
    if command -v lsof >/dev/null 2>&1; then
        lsof -i:"$port" >/dev/null 2>&1
        return $?
    elif command -v netstat >/dev/null 2>&1; then
        netstat -tuln | grep -q ":$port "
        return $?
    else
        verbose_log "Warning: Cannot check port $port (lsof/netstat not available)"
        return 0
    fi
}

#-------------------------------------------------------------
# check_process_health
# Verify that a process is responding (basic check)
# Parameters:
# - $1: process name
# - $2: port to check
# - $3: max wait time in seconds (default 30)
# Returns: 0 if healthy, 1 otherwise
#-------------------------------------------------------------
check_process_health() {
    local name=$1
    local port=$2
    local max_wait=${3:-30}
    local waited=0
    
    verbose_log "Health checking $name on port $port..."
    
    while [ $waited -lt $max_wait ]; do
        if check_port "$port"; then
            verbose_log "$name is responding on port $port"
            return 0
        fi
        sleep 1
        waited=$((waited + 1))
    done
    
    echo -e "${YELLOW}Warning: $name did not respond on port $port after ${max_wait}s${NC}"
    return 1
}

#-------------------------------------------------------------
# init_logging
# Ensures log directories and the global activity log file exist.
# Side effects:
# - Creates directories: `process_logs/` and `pids/` (mode inherits umask).
# - Creates an empty activity logfile at `astart_activity.log` if missing.
# This is safe to call multiple times.
#-------------------------------------------------------------
init_logging() {
    verbose_log "Initializing logging directories: $LOG_DIR"
    mkdir -p "$PROCESS_LOG_DIR"
    mkdir -p "$PID_DIR"
    touch "$ACTIVITY_LOG"
    verbose_log "Log directories created: process_logs=$PROCESS_LOG_DIR, pids=$PID_DIR"
}

#-------------------------------------------------------------
# get_instance_ip
# Attempts to determine the server's public IP for auditing purposes.
# Strategy (in order):
# 1) Query AWS metadata (http://169.254.169.254/latest/meta-data/public-ipv4).
#    - Note: IMDSv2 may require session token; this simple call uses IMDSv1.
#    - We use a short timeout to avoid blocking startup if metadata is not reachable.
# 2) Fallback to a public IP lookup service (`ifconfig.me`).
# 3) Fallback to local hostname inspection (`hostname -I` or `hostname`).
# Returns: IP string or `unknown` if detection fails.
# Side effects: performs network calls when `curl` is present.
#-------------------------------------------------------------
get_instance_ip() {
    # Prefer the SSH client IP when the launcher is invoked over SSH
    ip=$(echo "$SSH_CLIENT" | awk '{print $1}' 2>/dev/null || true)
    if [ -z "$ip" ]; then
        ip="unknown"
    fi
    echo "$ip"
}

#-------------------------------------------------------------
# log_activity
# Append a single-line, machine-friendly activity record to the global
# activity log. This log is intended for quick scans and aggregated
# auditing (timestamp, user, ip, flag, process).
# Parameters:
# - $1: flag (string) — the CLI flag or reason (e.g. -a, -b, -w, bg, launcher-exit)
# - $2: process name (string) — logical name used for process logs and pid files
# Example record:
# 2025-11-21T12:34:56Z | user=ubuntu | ip=3.120.45.67 | flag=-b | process=backend
#-------------------------------------------------------------
log_activity() {
    # params: flag, process_name
    flag="$1"
    pname="$2"
    ts=$(date -u +"%Y-%m-%dT%H:%M:%SZ")
    user=$(whoami 2>/dev/null || echo unknown)
    ip=$(get_instance_ip)
    verbose_log "Logging activity: flag=$flag, process=$pname, user=$user, ip=$ip"
    echo "$ts | user=$user | ip=$ip | flag=$flag | process=$pname" >> "$ACTIVITY_LOG"
}

#-------------------------------------------------------------
# log_process_start
# Writes a START block to the per-process logfile and records the
# invoked command for later debugging. Per-process logs contain:
# - A START header with timestamp and user
# - A `CMD:` line showing the exact shell command executed
# - The stdout/stderr captured (redirected by start_bg)
# The per-process logfile path is: `$PROCESS_LOG_DIR/<name>.log`.
# Parameters:
# - $1: name (string)
# - $2: cmd  (string) command executed
#-------------------------------------------------------------
log_process_start() {
    # params: name, cmd, [logfile]
    name="$1"
    cmd="$2"
    plog="${3:-$PROCESS_LOG_DIR/${name}.log}"
    ts=$(date -u +"%Y-%m-%dT%H:%M:%SZ")
    user=$(whoami 2>/dev/null || echo unknown)
    echo "==== START ${name} ${ts} user=${user} ====" >> "$plog"
    echo "CMD: $cmd" >> "$plog"
}

#-------------------------------------------------------------
# log_process_stop
# Appends a STOP header with timestamp and exit code to the process log.
# This complements the START header and signals that the process has
# terminated (normally or abnormally).
# Parameters:
# - $1: name (string)
# - $2: exit_code (integer)
#-------------------------------------------------------------
log_process_stop() {
    # params: name, exit_code, [logfile]
    name="$1"
    code="$2"
    plog="${3:-$PROCESS_LOG_DIR/${name}.log}"
    ts=$(date -u +"%Y-%m-%dT%H:%M:%SZ")
    echo "==== STOP ${name} ${ts} exit=${code} ====" >> "$plog"
}

#-------------------------------------------------------------
# _wait_and_log
# Internal helper used for background-started processes.
# - Waits for PID to exit, captures its exit code, writes a STOP
#   block to the process log, appends a one-line activity record,
#   and removes the pid file.
# - This function is launched in background for each start_bg PID so
#   it does not block the launcher.
# Parameters:
# - $1: name (string)
# - $2: pid  (integer)
#-------------------------------------------------------------
_wait_and_log() {
    name="$1"
    pid="$2"
    if [ -z "$pid" ] || [ "$pid" -eq 0 ] 2>/dev/null; then
        return
    fi
    # Poll for process liveness since this function may not be the parent
    # of the started process (wait would fail in that case). We detect
    # process termination and then write a STOP record. Exact exit code
    # is not available when not a parent; we record `UNKNOWN` in that case.
    while kill -0 "$pid" 2>/dev/null; do
        sleep 2
    done
    # Process exited; we cannot reliably obtain its exit code here.
    code="UNKNOWN"
    # Determine the logfile recorded in the pid file (if present)
    plog=$(sed -n '2p' "$PID_DIR/${name}.pid" 2>/dev/null || true)
    if [ -z "$plog" ]; then
        plog="$PROCESS_LOG_DIR/${name}.log"
    fi
    log_process_stop "$name" "$code" "$plog"
    # also append to global activity log
    ts=$(date -u +"%Y-%m-%dT%H:%M:%SZ")
    user=$(whoami 2>/dev/null || echo unknown)
    ip=$(get_instance_ip)
    echo "$ts | user=$user | ip=$ip | flag=bg | process=$name | pid=$pid | exit=$code" >> "$ACTIVITY_LOG"
    rm -f "$PID_DIR/${name}.pid"
}

#-------------------------------------------------------------
# start_bg
# Start a command in background while wiring logging and pid tracking.
# Behavior:
# - Initializes logging directories/files.
# - Writes a one-line activity entry and a START block in process log.
# - Uses `nohup` + `bash -lc` to background the command and redirect
#   stdout/stderr into the process log file.
# - Stores the background PID into `$PID_DIR/<name>.pid`.
# - Launches `_wait_and_log` in the background to monitor and record
#   the process termination (STOP block + activity entry) and clean up
#   the pid file.
# Parameters:
# - $1: name (string)
# - $2: flag (string)
# - $3: cmd  (string) the shell command to run
# Returns: 0 on successful start (note: the process itself may fail later).
#-------------------------------------------------------------
start_bg() {
    # params: name, flag, cmd, [optional_port_for_health_check]
    name="$1"
    flag="$2"
    cmd="$3"
    health_port="$4"
    
    verbose_log "Starting background process: $name"
    verbose_log "Command: $cmd"
    init_logging
    
    # Create a timestamped logfile for this run
    TIMESTAMP=$(date +"%H-%M-%S_%d-%m-%Y")
    logfile="$PROCESS_LOG_DIR/${name}_${TIMESTAMP}.log"
    verbose_log "Log file: $logfile"
    log_activity "$flag" "$name"
    log_process_start "$name" "$cmd" "$logfile"
    
    nohup bash -lc "$cmd" >> "$logfile" 2>&1 &
    pid=$!
    
    # Verify process actually started
    sleep 0.5
    if ! kill -0 "$pid" 2>/dev/null; then
        echo -e "${RED}ERROR: Failed to start $name (PID $pid exited immediately)${NC}"
        echo -e "${YELLOW}Check log: $logfile${NC}"
        return 1
    fi
    
    verbose_log "Process $name started with PID: $pid"
    echo -e "${GREEN}✓ $name started (PID: $pid)${NC}"
    
    # Store both pid and logfile path so stop/wait routines can find the file
    printf "%s\n%s\n" "$pid" "$logfile" > "$PID_DIR/${name}.pid"
    
    # record the pid immediately in the global activity log
    ts=$(date -u +"%Y-%m-%dT%H:%M:%SZ")
    user=$(whoami 2>/dev/null || echo unknown)
    ip=$(get_instance_ip)
    echo "$ts | user=$user | ip=$ip | flag=$flag | process=$name | pid=$pid | logfile=$(basename "$logfile") | state=started" >> "$ACTIVITY_LOG"
    
    # spawn waiter to log stop when it finishes
    (_wait_and_log "$name" "$pid") &
    
    # Optionally check health if port provided
    if [ -n "$health_port" ]; then
        check_process_health "$name" "$health_port" 10 || true
    fi
    
    return 0
}

#-------------------------------------------------------------
# start_fg
# Run a command in the foreground while recording start/stop entries.
# Behavior:
# - Writes a START block to the per-process log and a one-line activity
#   record indicating the start.
# - Executes the command in the foreground so the user sees live output.
# - When the command exits, writes a STOP block and appends a one-line
#   activity entry with the exit code.
# Parameters:
# - $1: name (string)
# - $2: flag (string)
# - $3: cmd  (string) the shell command to run
# Returns: the exit code from the executed command.
#-------------------------------------------------------------
start_fg() {
    # params: name, flag, cmd
    name="$1"
    flag="$2"
    cmd="$3"
    verbose_log "Starting foreground process: $name"
    verbose_log "Command: $cmd"
    init_logging
    # Create a timestamped logfile for this run
    TIMESTAMP=$(date +"%H-%M-%S_%d-%m-%Y")
    logfile="$PROCESS_LOG_DIR/${name}_${TIMESTAMP}.log"
    verbose_log "Log file: $logfile"
    log_activity "$flag" "$name"
    log_process_start "$name" "$cmd" "$logfile"
    # run the command and tee its output to both the console and the
    # per-process logfile so that runtime output is persisted.
    # Use a subshell with pipefail so the subshell exit code reflects
    # failures from the command (not just tee). The subshell's output
    # is piped to `tee -a` which appends to the log and also writes to
    # the user's terminal.
    (
        set -o pipefail
        bash -lc "$cmd" 2>&1 | tee -a "$logfile"
    )
    code=$?
    log_process_stop "$name" "$code" "$logfile"
    ts=$(date -u +"%Y-%m-%dT%H:%M:%SZ")
    user=$(whoami 2>/dev/null || echo unknown)
    ip=$(get_instance_ip)
    echo "$ts | user=$user | ip=$ip | flag=$flag | process=$name | exit=$code | logfile=$(basename "$logfile")" >> "$ACTIVITY_LOG"
    return $code
}

#---------------------------------------------
# On exit handler to log running processes
#  
#---------------------------------------------

#-------------------------------------------------------------
# on_exit
# Trap handler executed when the launcher process exits.
# Purpose:
# - Inspect stored pid files and record in the global activity log which
#   of those PIDs were still running at launcher exit. This is useful
#   for post-mortem or automated monitoring to know which services
#   remained active after the launcher terminated.
# Notes:
# - Does not attempt to kill processes; it only records state.
# - Safe to run multiple times; uses `kill -0` to test liveness.
#-------------------------------------------------------------
on_exit() {
    # When launcher exits, note current PIDs still running
    init_logging
    ts=$(date -u +"%Y-%m-%dT%H:%M:%SZ")
    user=$(whoami 2>/dev/null || echo unknown)
    ip=$(get_instance_ip)
    for f in "$PID_DIR"/*.pid; do
        [ -e "$f" ] || continue
        name=$(basename "$f" .pid)
        pid=$(sed -n '1p' "$f" 2>/dev/null || true)
        if [ -n "$pid" ] && kill -0 "$pid" 2>/dev/null; then
            echo "$ts | user=$user | ip=$ip | launcher-exit | process=$name | pid=$pid | state=running" >> "$ACTIVITY_LOG"
        fi
    done
}

trap on_exit EXIT

#-------------------------------------------------------------
# stop_all
# Stop all processes that were started by this launcher (reads pid files)
# Behavior:
# - Iterates over `$PID_DIR/*.pid` files, reads the PID and logical name
# - Attempts graceful shutdown: SIGTERM, wait up to 5 seconds, then SIGKILL
# - Writes per-process STOP entry and a one-line activity record
# - Removes pid file after process is no longer running
#-------------------------------------------------------------
stop_all() {
    verbose_log "Stopping all services..."
    init_logging
    ts=$(date -u +"%Y-%m-%dT%H:%M:%SZ")
    user=$(whoami 2>/dev/null || echo unknown)
    ip=$(get_instance_ip)

    for f in "$PID_DIR"/*.pid; do
        [ -e "$f" ] || continue
        name=$(basename "$f" .pid)
        verbose_log "Processing PID file for: $name"
        pid=$(sed -n '1p' "$f" 2>/dev/null || true)
        plog=$(sed -n '2p' "$f" 2>/dev/null || true)
        if [ -z "$pid" ]; then
            echo "$ts | user=$user | ip=$ip | flag=-s | process=$name | state=no-pid" >> "$ACTIVITY_LOG"
            rm -f "$f"
            continue
        fi

        if ! kill -0 "$pid" 2>/dev/null; then
            echo "$ts | user=$user | ip=$ip | flag=-s | process=$name | pid=$pid | state=not-running" >> "$ACTIVITY_LOG"
            rm -f "$f"
            continue
        fi

        # Attempt graceful shutdown
        verbose_log "Sending SIGTERM to $name (PID: $pid)"
        echo "$ts | user=$user | ip=$ip | flag=-s | process=$name | pid=$pid | action=term" >> "$ACTIVITY_LOG"
        kill "$pid" 2>/dev/null || true

        # Wait up to 5 seconds for process to exit
        waited=0
        while kill -0 "$pid" 2>/dev/null; do
            sleep 0.5
            waited=$((waited + 1))
            if [ $waited -ge 10 ]; then
                # escalate to SIGKILL
                verbose_log "Process $name did not stop gracefully, sending SIGKILL"
                echo "$ts | user=$user | ip=$ip | flag=-s | process=$name | pid=$pid | action=kill" >> "$ACTIVITY_LOG"
                kill -9 "$pid" 2>/dev/null || true
                break
            fi
        done

        # Determine which logfile to mark stopped (if stored in pid file)
        if [ -z "$plog" ]; then
            plog="$PROCESS_LOG_DIR/${name}.log"
        fi
        ts2=$(date -u +"%Y-%m-%dT%H:%M:%SZ")
        if kill -0 "$pid" 2>/dev/null; then
            echo "==== STOP ${name} ${ts2} exit=KILLED ====" >> "$plog"
            echo "$ts2 | user=$user | ip=$ip | flag=-s | process=$name | pid=$pid | exit=KILLED" >> "$ACTIVITY_LOG"
        else
            echo "==== STOP ${name} ${ts2} exit=STOPPED ====" >> "$plog"
            echo "$ts2 | user=$user | ip=$ip | flag=-s | process=$name | pid=$pid | exit=STOPPED" >> "$ACTIVITY_LOG"
        fi

        rm -f "$f"
    done
}



#-------------------------------------------------------------
# show_status
# Display status of all services
#-------------------------------------------------------------
show_status() {
    init_logging
    echo -e "${BLUE}=== Service Status ===${NC}"
    
    local any_running=0
    for f in "$PID_DIR"/*.pid; do
        [ -e "$f" ] || continue
        name=$(basename "$f" .pid)
        pid=$(sed -n '1p' "$f" 2>/dev/null || true)
        
        if [ -n "$pid" ] && kill -0 "$pid" 2>/dev/null; then
            echo -e "${GREEN}✓${NC} $name (PID: $pid) - ${GREEN}RUNNING${NC}"
            any_running=1
        else
            echo -e "${RED}✗${NC} $name - ${RED}NOT RUNNING${NC} (stale PID file)"
            rm -f "$f"
        fi
    done
    
    if [ $any_running -eq 0 ]; then
        echo -e "${YELLOW}No services are currently running${NC}"
    fi
}

#-------------------------------------------------------------
# restart_service
# Restart a specific service
# Parameters:
# - $1: service name
#-------------------------------------------------------------
restart_service() {
    local service="$1"
    
    if [ -z "$service" ]; then
        echo -e "${RED}ERROR: No service specified${NC}"
        echo "Usage: $0 -r <service_name>"
        echo "Available services: backend, loginreg, ai_api, web_ui, ai_chatbot_web, ai_chatbot_api"
        return 1
    fi
    
    echo -e "${BLUE}Restarting $service...${NC}"
    
    # Stop the service if running
    if [ -f "$PID_DIR/${service}.pid" ]; then
        local pid=$(sed -n '1p' "$PID_DIR/${service}.pid" 2>/dev/null || true)
        if [ -n "$pid" ] && kill -0 "$pid" 2>/dev/null; then
            echo -e "${YELLOW}Stopping $service (PID: $pid)...${NC}"
            kill "$pid" 2>/dev/null || true
            sleep 2
            if kill -0 "$pid" 2>/dev/null; then
                kill -9 "$pid" 2>/dev/null || true
            fi
        fi
        rm -f "$PID_DIR/${service}.pid"
    fi
    
    # Start the service
    case "$service" in
        backend)
            backend_start
            ;;
        loginreg)
            loginreg_script
            ;;
        ai_api|ai_chatbot_api)
            ai_chatbot_api_only
            ;;
        web_ui)
            start_web_ui
            ;;
        ai_chatbot_web)
            ai_chatbot_with_web
            ;;
        *)
            echo -e "${RED}ERROR: Unknown service: $service${NC}"
            return 1
            ;;
    esac
}

#-------------------------------------------------------------
# view_logs
# View logs for a specific service or all logs
# Parameters:
# - $1: service name (optional, 'all' for all logs)
# - $2: follow flag (optional, 'follow' to tail -f)
#-------------------------------------------------------------
view_logs() {
    local service="$1"
    local follow="$2"
    
    init_logging
    
    if [ -z "$service" ] || [ "$service" = "all" ]; then
        echo -e "${BLUE}=== Available Log Files ===${NC}"
        ls -lht "$PROCESS_LOG_DIR" 2>/dev/null || echo "No logs found"
        return 0
    fi
    
    # Find the most recent log for the service
    local logfile=$(ls -t "$PROCESS_LOG_DIR/${service}_"*.log 2>/dev/null | head -n1)
    
    if [ -z "$logfile" ]; then
        echo -e "${RED}ERROR: No logs found for service: $service${NC}"
        return 1
    fi
    
    echo -e "${BLUE}=== Log: $logfile ===${NC}"
    
    if [ "$follow" = "follow" ]; then
        tail -f "$logfile"
    else
        tail -n 50 "$logfile"
    fi
}

#-------------------------------------------------------------
# Function to start the chatbot with streamlit web interface
#-------------------------------------------------------------

ai_chatbot_with_web(){
    validate_paths || return 1
    
    # Run Streamlit web UI in foreground with logging
    cmd="cd \"$core_path\" && streamlit run app.py"
    # keep Streamlit in foreground so the developer can see live UI logs
    start_fg "ai_chatbot_web" "-c" "$cmd"
}


#-------------------------------------------------------------
# Function to start the OTP service 
#-------------------------------------------------------------

OTP_satrt(){
    validate_paths || return 1
    
    # Check if port is already in use
    if check_port "$OTP_PORT"; then
        echo -e "${RED}ERROR: Port $OTP_PORT is already in use${NC}"
        return 1
    fi
    cmd="cd \"$otp_dir\" && python3 OTP_W.py"
    # keep Streamlit in foreground so the developer can see live UI logs
    start_fg "otp_service" "-c" "$cmd"
}

#-------------------------------------------------------------
# To run only the API without the web interface
#-------------------------------------------------------------

ai_chatbot_api_only(){
    validate_paths || return 1
    
    # Check if port is already in use
    if check_port "$API_PORT"; then
        echo -e "${RED}ERROR: Port $API_PORT is already in use${NC}"
        return 1
    fi
    
    # Run API in background; output goes to process log only
    cmd="cd \"$core_path\" && python3 api.py"
    start_bg "ai_chatbot_api" "-a" "$cmd" "$API_PORT"
}


# Function to start the Frontend server
start_web_ui() {
    validate_paths || return 1
    
    # Check if port is already in use
    if check_port "$WEB_UI_PORT"; then
        echo -e "${RED}ERROR: Port $WEB_UI_PORT is already in use${NC}"
        return 1
    fi
    
    # Run frontend (vite) in foreground with logging
    cmd="cd \"$webui_path\" && npm run dev -- --host 0.0.0.0"
    start_fg "web_ui" "-web" "$cmd"
}

#-------------------------------------------------------------
# Function to start the Backend server
#Note: This function assumes that Maven is installed and configured properly.
# Also, it assumes that the database connection details are correct.
#if there are any issues with the database connection, the backend may fail to start.
#-------------------------------------------------------------

backend_start() {
    validate_paths || return 1
    
    # Check if port is already in use
    if check_port "$BACKEND_PORT"; then
        echo -e "${RED}ERROR: Port $BACKEND_PORT is already in use${NC}"
        return 1
    fi
    
    # Run backend in background using environment variables for credentials
    cmd="cd \"$backend_path\" && mvn clean spring-boot:run -Dspring-boot.run.arguments=\"--spring.datasource.url=$DB_URL --spring.datasource.username=$DB_USERNAME --spring.datasource.password=$DB_PASSWORD\""
    start_bg "backend" "-b" "$cmd" "$BACKEND_PORT"
}

#-------------------------------------------------------------
#Function to run the login/registration script (temporary)
#-------------------------------------------------------------

loginreg_script() {
    validate_paths || return 1
    
    # Check if port is already in use
    if check_port "$LOGIN_API_PORT"; then
        echo -e "${RED}ERROR: Port $LOGIN_API_PORT is already in use${NC}"
        return 1
    fi
    
    # Run login/registration script in background; output goes to process log only
    cmd="cd \"$backend_path\" && python3 loginapi.py"
    start_bg "loginreg" "-x" "$cmd" "$LOGIN_API_PORT"
}

#-------------------------------------------------------------
#Function to run the whole system (temporary parts)
#-------------------------------------------------------------
run_whole_system() {
    validate_paths || return 1
    
    echo -e "${BLUE}Starting all services...${NC}"
    
    # Start backend, login script, and API in background
    backend_start || echo -e "${YELLOW}Warning: Backend failed to start${NC}"
    sleep 2
    
    loginreg_script || echo -e "${YELLOW}Warning: Login/Registration API failed to start${NC}"
    sleep 2
    
    ai_chatbot_api_only || echo -e "${YELLOW}Warning: AI API failed to start${NC}"
    sleep 2
    
    echo -e "${GREEN}Background services started${NC}"
    echo -e "${BLUE}Starting Web UI (foreground)...${NC}"
    
    # Start web UI in foreground so user sees its output
    start_fg "web_ui" "-w" "cd \"$webui_path\" && npm run dev -- --host 0.0.0.0"
    
    # wait for any background waiters (they log stops independently)
    wait
}


#---------------------------------------------------------------------
#Function to fetch the latest code from the repository and update the 
#Production server 
#---------------------------------------------------------------------

update_production_server() {
    echo -e "${GREEN}Updating production server...${NC}"

    # Validate target directory (safety check)
    if [ ! -d "$server_dir" ] || [ -z "$server_dir" ] || [ "$server_dir" = "/" ]; then
        echo -e "${RED}ERROR: Invalid or dangerous server_dir: '$server_dir'${NC}"
        exit 1
    fi

    # Move to the web UI directory
    cd "$webui_path" || { 
        echo -e "${RED}Failed to change directory to $webui_path${NC}"
        exit 1
    }

    # Pull latest changes
    git pull origin main || { 
        echo -e "${RED}Git pull failed. Please check your network or repo status.${NC}"
        exit 1
    }
    echo -e "${GREEN}Production server updated from Git successfully.${NC}"

    # Build project
    npm run build || { 
        echo -e "${RED}Build failed. Check the build logs for details.${NC}"
        exit 1
    }

    # Remove old production files except .htaccess
    echo -e "${GREEN}Cleaning old production files...${NC}"
    sudo find "$server_dir" -mindepth 1 ! -name ".htaccess" -exec rm -rf {} + || { 
        echo -e "${RED}Failed to remove old files from $server_dir${NC}"
        exit 1
    }
    echo -e "${GREEN}Old files removed from $server_dir successfully.${NC}"

    # Copy new build
    sudo cp -r dist/* "$server_dir"/ || { 
        echo -e "${RED}Failed to copy files to $server_dir${NC}"
        exit 1
    }
    echo -e "${GREEN}Files copied to $server_dir successfully.${NC}"

    echo -e "${GREEN}Deployment completed successfully!${NC}"
}

 
#-------------------------------------------------------------
# Function to display help message
#-------------------------------------------------------------
display_help() {
    echo -e "${BLUE}=============================================================${NC}"
    echo -e "${BLUE}  Teeth Management System - Service Launcher${NC}"
    echo -e "${BLUE}=============================================================${NC}"
    echo ""
    echo -e "${GREEN}Usage:${NC} $0 [options]"
    echo ""
    echo -e "${GREEN}Service Control:${NC}"
    echo -e "  ${RED}-w${NC}    Start the whole system (Backend, Login API, AI API, Web UI)"
    echo -e "  ${RED}-b${NC}    Start Backend server only"
    echo -e "  ${RED}-x${NC}    Start Login/Registration API only"
    echo -e "  ${RED}-a${NC}    Start AI Chatbot API only"
    echo -e "  ${RED}-c${NC}    Start Web UI (Frontend) only"
    echo -e "  ${RED}-s${NC}    Stop all running services"
    echo -e "  ${RED}-l${NC}    List status of all services"
    echo -e "  ${RED}-o${NC}    Start OTP Service"
    echo -e "  ${RED}-r${NC} ${YELLOW}<service>${NC}  Restart a specific service"
    echo ""
    echo -e "${GREEN}Logs & Monitoring:${NC}"
    echo -e "  ${RED}-L${NC} ${YELLOW}<service>${NC}  View logs for a service (latest 50 lines)"
    echo -e "  ${RED}-F${NC} ${YELLOW}<service>${NC}  Follow logs for a service (tail -f)"
    echo -e "  ${RED}-L${NC} ${YELLOW}all${NC}       List all available log files"
    echo ""
    echo -e "${GREEN}Deployment:${NC}"
    echo -e "  ${RED}-u${NC}    Update and deploy to production server"
    echo ""
    echo -e "${GREEN}Other:${NC}"
    echo -e "  ${RED}-v${NC}    Enable verbose/debug output"
    echo -e "  ${RED}-h${NC}    Display this help message"
    echo ""
    echo -e "${GREEN}Examples:${NC}"
    echo -e "  $0 -w                    # Start all services"
    echo -e "  $0 -v -b                 # Start backend with verbose output"
    echo -e "  $0 -l                    # Check service status"
    echo -e "  $0 -r backend            # Restart backend service"
    echo -e "  $0 -L web_ui             # View web UI logs"
    echo -e "  $0 -F ai_chatbot_api     # Follow AI API logs"
    echo -e "  $0 -o                    # Start OTP service"
    echo ""
    echo -e "${GREEN}Available Services:${NC}"
    echo -e "  - backend              (Spring Boot backend on port ${BACKEND_PORT})"
    echo -e "  - loginreg             (Login/Registration API on port ${LOGIN_API_PORT})"
    echo -e "  - ai_chatbot_api       (AI Chatbot API on port ${API_PORT})"
    echo -e "  - web_ui               (Vite Frontend on port ${WEB_UI_PORT})"
    echo -e "  - ai_chatbot_web       (Streamlit Web Interface)"
    echo ""
    echo -e "${GREEN}Logs Location:${NC}"
    echo -e "  Activity Log:  ${YELLOW}$ACTIVITY_LOG${NC}"
    echo -e "  Process Logs:  ${YELLOW}$PROCESS_LOG_DIR${NC}"
    echo -e "  PID Files:     ${YELLOW}$PID_DIR${NC}"
    echo ""
    exit 0
}


#-------------------------------------------------------------
# Main script logic to parse command-line arguments
#-------------------------------------------------------------

# Parse command-line options robustly.
# - If ASTART_DEBUG=1, print debug info about received arguments.
DEBUG=${ASTART_DEBUG:-0}
if [ "$DEBUG" -eq 1 ] 2>/dev/null; then
    echo "DEBUG: invoked as: $0 $*" >&2
fi

# Track if we need an argument for certain options
NEED_ARG=""

while getopts ":cauwbxsvhlro:L:F:" option; do
    case $option in
        v)
            VERBOSE=1
            echo -e "${YELLOW}[VERBOSE MODE ENABLED]${NC}"
            verbose_log "Script invoked as: $0 $*"
            verbose_log "Paths configured:"
            verbose_log "  - AI Chatbot: $core_path"
            verbose_log "  - Web UI: $webui_path"
            verbose_log "  - Backend: $backend_path"
            verbose_log "  - Log directory: $LOG_DIR"
            verbose_log "Database: $DB_URL (user: $DB_USERNAME)"
            verbose_log "Ports: Web=$WEB_UI_PORT, Backend=$BACKEND_PORT, API=$API_PORT, Login=$LOGIN_API_PORT"
            ;;
        c)
            echo -e "${GREEN}Starting Web UI (Frontend)...${NC}"
            verbose_log "Executing: start_web_ui"
            start_web_ui
            ;;
        u)
            echo -e "${GREEN}Update Production Server...${NC}"
            verbose_log "Executing: update_production_server"
            update_production_server
            exit 0
            ;;
        a)
            echo -e "${GREEN}Starting AI Chatbot API Only...${NC}"
            verbose_log "Executing: ai_chatbot_api_only"
            ai_chatbot_api_only
            exit 0
            ;;
        w)
            echo -e "${GREEN}Starting the whole system...${NC}"
            verbose_log "Executing: run_whole_system"
            run_whole_system
            ;;
        b)
            echo -e "${GREEN}Starting Backend server only...${NC}"
            verbose_log "Executing: backend_start"
            backend_start
            exit 0
            ;;
        x)
            echo -e "${GREEN}Starting Login/Registration API only...${NC}"
            verbose_log "Executing: loginreg_script"
            loginreg_script
            exit 0
            ;;
        l)
            verbose_log "Executing: show_status"
            show_status
            exit 0
            ;;
        r)
            verbose_log "Executing: restart_service $OPTARG"
            restart_service "$OPTARG"
            exit 0
            ;;
        o)
            echo -e "${GREEN}Starting OTP Service...${NC}"
            verbose_log "Executing: OTP_start"
            OTP_satrt
            exit 0
            ;;
        L)
            verbose_log "Executing: view_logs $OPTARG"
            view_logs "$OPTARG"
            exit 0
            ;;
        F)
            verbose_log "Executing: view_logs $OPTARG follow"
            view_logs "$OPTARG" "follow"
            exit 0
            ;;
        h)
            display_help
            ;;
        s)
            echo -e "${GREEN}Stopping all services started by astart...${NC}"
            verbose_log "Executing: stop_all"
            stop_all
            exit 0
            ;;
        \?)
            # Unknown option (getopts sets OPTARG to the option character)
            echo -e "${RED}Invalid option: -${OPTARG}${NC}"
            echo -e "Use ${YELLOW}$0 -h${NC} for help."
            exit 1
            ;;
        :)
            # Missing option argument
            echo -e "${RED}Option -${OPTARG} requires an argument${NC}"
            echo -e "Use ${YELLOW}$0 -h${NC} for help."
            exit 1
            ;;
        *)
            echo -e "${RED}Invalid option. Please try again.${NC}"
            exit 1
            ;;
    esac
done

if [ $OPTIND -eq 1 ]; then
    echo -e "${RED}No options were passed.${NC}"
    echo -e "Use ${YELLOW}$0 -h${NC} for help."
    exit 1
fi
 